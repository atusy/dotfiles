### Added by Zinit's installer
if [[ ! -f $HOME/.zinit/bin/zinit.zsh ]]; then
    print -P "%F{33}▓▒░ %F{220}Installing %F{33}DHARMA%F{220} Initiative Plugin Manager (%F{33}zdharma-continuum/zinit%F{220})…%f"
    command mkdir -p "$HOME/.zinit" && command chmod g-rwX "$HOME/.zinit"
    command git clone https://github.com/zdharma-continuum/zinit "$HOME/.zinit/bin" && \
        print -P "%F{33}▓▒░ %F{34}Installation successful.%f%b" || \
        print -P "%F{160}▓▒░ The clone has failed.%f%b"
fi

source "$HOME/.zinit/bin/zinit.zsh"
autoload -Uz _zinit
(( ${+_comps} )) && _comps[zinit]=_zinit
### End of Zinit's installer chunk

# Global profile (shared with bash)
# keep as a comment while testing if .zprofile works
# [[ -f "$HOME/.profile" ]] && . "$HOME/.profile"

# PROMPT
function gitprompt() {
  # will be overridden by woefe/git-prompt.zsh
  # the blank function here suppresses potential error from lazy loading
  :
}
function kube_ps1 {
  :
}
function kubeprompt() {
  # show if KUBECONFIG is set or any context is being used
  if [[ "${KUBE_PS1_CONTEXT:-N/A}" != "N/A" ]]; then
    kube_ps1 # will be defined by jonmosco/kube-ps1
  fi
}
ZSH_THEME_GIT_PROMPT_PREFIX=" "
ZSH_THEME_GIT_PROMPT_SUFFIX=""
ZSH_THEME_GIT_PROMPT_UNTRACKED=".."
ZSH_THEME_GIT_PROMPT_UNMERGED="%{$fg[red]%}x"
ZSH_THEME_GIT_PROMPT_STAGED="%{$fg[green]%}o"
ZSH_THEME_GIT_PROMPT_UNSTAGED="%{$fg[red]%}+"
PROMPT_ACCENT_COLOR="$( test -n "$SSH_CLIENT" && echo cyan || echo 112 )"
PROMPT='%F{${PROMPT_ACCENT_COLOR}}[ %3~ ]%F{white}$(gitprompt) $(kubeprompt)
%F{${PROMPT_ACCENT_COLOR}}» '

# Load plugins
zinit light-mode for \
    zdharma-continuum/zinit-annex-as-monitor \
    zdharma-continuum/zinit-annex-bin-gem-node \
    zdharma-continuum/zinit-annex-patch-dl \
    zdharma-continuum/zinit-annex-rust

zinit wait lucid for \
 atinit"ZINIT[COMPINIT_OPTS]=-C; zicompinit; zicdreplay" \
    zdharma-continuum/fast-syntax-highlighting \
 blockf \
    zsh-users/zsh-completions \
 atload"!_zsh_autosuggest_start" \
    zsh-users/zsh-autosuggestions

zinit ice depth"1" wait lucid
zinit light-mode for \
  mafredri/zsh-async \
  chrissicool/zsh-256color \
  woefe/git-prompt.zsh \
  jonmosco/kube-ps1 \
  mollifier/cd-gitroot \
  yuki-yano/zeno.zsh \
  junegunn/fzf \
  atusy/zsh-nvrepl \
  atusy/gh-fzf

bindkey -e
bindkey "^[[3~" delete-char # Del is delete-char, not tilde

# History
HISTFILE=~/.zsh_history
HISTSIZE=100000
SAVEHIST=100000
setopt \
  hist_ignore_all_dups \
  hist_ignore_space \
  hist_no_store \
  hist_reduce_blanks \
  hist_save_no_dups \
  hist_verify \
  share_history \
  inc_append_history

# cd
setopt autocd auto_pushd pushd_ignore_dups

# else
setopt \
  extended_glob \
  mark_dirs \
  interactive_comments \
  noautoremoveslash \
  nomatch \
  notify \
  no_beep \
  no_flow_control \
  no_list_beep \
  numeric_glob_sort \
  print_eight_bit \
  prompt_subst

# completion
LISTMAX=1000
setopt \
  always_last_prompt \
  auto_list \
  auto_menu \
  auto_param_keys \
  auto_param_slash \
  complete_aliases \
  complete_in_word \
  list_types \
  magic_equal_subst \
  menu_complete

## zstyle
### Basic Configuration
zstyle ':completion:*' verbose yes
zstyle ':completion:*' menu select interactive
zstyle ':completion:*' group-name ''
zstyle ':completion:*' completer _expand _complete _match _prefix _approximate _list
zstyle ':completion:*' matcher-list  'm:{a-zA-Z}={A-Za-z}' 'r:|[._-]=* r:|=*' 'l:|=* r:|=*'
zstyle ':completion:*' special-dirs true
zstyle ':completion:*' auto-description 'Specify: %d'
zstyle ':completion:*' select-prompt %SScrolling Active: Current selection at %p%s
zstyle ':completion:*' list-prompt %SAt %p: Hit TAB for more, or the character to insert%s
zstyle ':completion:*:options'         description 'yes'
zstyle ':completion:*:*:-subscript-:*' tag-order indexes parameters

### Highlight
# zstyle ':completion:*'              list-colors "${(s.:.)LS_COLORS}"
zstyle ':completion:*'              list-colors "di=01;34:ln=01;35:so=01;32:ex=01;31:bd=46;34:cd=43;34:su=41;30:sg=46;30:tw=42;30:ow=43;30"
zstyle ':completion:*:messages'     format "$YELLOW" '%d' "$DEFAULT"
zstyle ':completion:*:warnings'     format "$RED" 'No matches for:' "$YELLOW" '%d' "$DEFAULT"
zstyle ':completion:*:descriptions' format "$YELLOW" 'Completing %B%d%b' "$DEFAULT"
zstyle ':completion:*:corrections'  format "$YELLOW" '%B%d% ' "$RED" '(Errors: %e)%b' "$DEFAULT"

### Separator
zstyle ':completion:*'         list-separator ' ==> '
zstyle ':completion:*:manuals' separate-sections true

### Cache
zstyle ':completion:*' use-cache on
zstyle ':completion:*' cache-path "$HOME/.zsh/cache"

### Others
zstyle ':completion:*' remote-access false
zstyle ':completion:*:sudo:*' command-path $path
zstyle ':completion:*' matcher-list 'm:{a-z}={A-Z}'
zstyle ':completion::complete:*' use-cache true

# Edit command line with favorite editor
autoload -Uz edit-command-line
function edit-command-line2() {
  EDITOR="${EDITOR_CMD:-$EDITOR}" edit-command-line
}
zle -N edit-command-line2
bindkey "^x^e" edit-command-line2

# Aliases and some useful functions
alias sudo='sudo '
if command -v zoxide > /dev/null; then
  if [[ "$(command -v zi)" =~ "^alias .+" ]]; then
    unalias zi
  fi
  eval "$(zoxide init zsh)"
fi
if command -v htop > /dev/null; then
  alias top='htop'
fi
if command -v duf > /dev/null; then
  alias df='duf'
else
  alias df='df -h'
fi
if command -v procs > /dev/null; then
  alias ps='procs'
fi
if command -v gdu > /dev/null; then
  alias du='gdu'
fi
if command -v exa > /dev/null; then
  alias ls='exa -l --time-style=iso --color=always'
fi
if command -v bat > /dev/null; then
  alias cat='bat'
fi
if command -v gojq > /dev/null; then
  alias jq='gojq'
  alias yq='gojq --yaml-input'
fi
if command -v wget2 > /dev/null
then
  alias wget='wget2 -c' # resumable
elif command -v wget > /dev/null; then
  alias wget='wget -c' # resumable
fi
if command -v nvim > /dev/null; then
  alias vim='nvim'
  if [[ -n $NVIM_LISTEN_ADDRESS ]] && command -v nvr > /dev/null; then
    function man() {
      if [[ $# -eq 1 ]]; then
        nvr -cc "Man $1" 2>/dev/null || command man "$1"
      else
        command man "$@"
      fi
    }
  fi
fi
if command -v xdg-open > /dev/null; then
  function open() {
    xdg-open "$@" 2>/dev/null
  }
fi
if which cd-gitroot 1>/dev/null; then
  alias gd='cd-gitroot'
fi

# example: printpath | fzf --ansi --preview 'exa --oneline {}'
function printpath() {
  if [[ -z "$path" ]]; then
    echo "$PATH" | grep -oE "[^:]+"
  else
    for i in "${path[@]}"; do
      echo "$i"
    done
  fi
}

if command -v kubectl > /dev/null; then
  # export KUBECONFIG="${KUBECONFIG:-/dev/null}"
  function kubeconfig() {
    local RES
    local CODE
    local LIST
    LIST="$(
      find "${1:-${HOME}/.kube}" -mindepth 1 -maxdepth 1 -type f | grep -v '/kubectx$' # exclude kubectx
      echo "/dev/null" # to disable kubectl
    )"
    RES="$( echo "$LIST" | fzf --preview 'cat {}' )"
    CODE="$?"
    if [[ $CODE -ne 0 ]]; then
      return $CODE
    fi
    export KUBECONFIG="$RES"
  }
  # function _kubectl() {
  #   if [[ -z "${KUBECONFIG:-}" ]]; then
  #     echo 'explicitly export KUBECONFIG before using kubectl' 1>&2
  #     return 1
  #   else
  #     command kubectl "$@"
  #   fi
  # }
  # alias kubectl='_kubectl'
  alias kunset='command kubectl config unset current-context'
fi

if command -v asdf >/dev/null; then
  # asdf meets fzf
  function asdff() {
    # determine plugin with fzf if not given
    local TARGET="local"
    if [[ "$1" == "global" ]]; then
      TARGET="global"
      shift 1
    fi
    local PLUGIN="$1"
    if [[ -z "$PLUGIN" ]]; then
      PLUGIN="$( asdf plugin list | fzf )"
      if [[ -z "$PLUGIN" ]]; then
        return 1
      fi
    elif [[ "$PLUGIN" == "-" ]]; then
      PLUGIN="$( asdf plugin list all | fzf | awk '{print $1}' )"
      if [[ -z "$PLUGIN" ]]; then
        return 1
      fi
      asdf plugin add "$PLUGIN"
    fi

    # determine version with fzf
    local VERSION
    local QUERY="${2:-}"
    if [[ -z "$QUERY" ]]; then
      # set default query for specific plugin
      if [[ "$PLUGIN" == "python" ]]; then
        QUERY="^3."
      fi
    fi
    VERSION="$( asdf list all "$PLUGIN" | fzf --tac --no-sort -q "$QUERY" )"
    if [[ -z "$VERSION" ]]; then
      return 1
    fi

    # apply plugin with the given version
    # install the specified version if necessary
    if asdf list "$PLUGIN" "$VERSION" >/dev/null
    then
      asdf "$TARGET" "$PLUGIN" "$VERSION"
    else
      asdf install "$PLUGIN" "$VERSION" && asdf "$TARGET" "$PLUGIN" "$VERSION"
    fi
  }
fi

if command -v pyenv >/dev/null; then
  function pyset() {
    local PYSET_IMPLICIT_GLOBAL=${PYSET_IMPLICIT_GLOBAL:-true}
    local PYSET_MAX_HEIGHT=${PYSET_MAX_HEIGHT:-10}
    local SCOPE="${1:-local}"
    local PATTERN="${2:-${PYSET_PATTERN:-^[0-9]+\.}}"
    local TARGET="$(
      CANDIDATES="$(
        pyenv install --list \
          | awk '{ print $1 }' \
          | command grep -E "$PATTERN"
        [[ -f .python-version ]] && echo "$( cat .python-version ) (.python-version)"
      )"
      HEIGHT="$(
        N="$(echo "$CANDIDATES" | wc -l)"
        echo "$(( $N + 2 ))\n${PYSET_MAX_HEIGHT}" \
          | sort -nu \
          | head -n 1
      )"
      echo "$CANDIDATES" | command fzf --height="$HEIGHT" --tac | awk '{ print $1 }'
    )"
    if [[ "$TARGET" == "" ]]
    then
      if ! $PYSET_IMPLICIT_GLOBAL
      then
        return 1
      fi
      echo "Using global python..." 1>&2
      TARGET="$( python --version | sed -E -e 's/^Python\s+//' )"
    fi
    pyenv install --skip-existing "$TARGET"
    pyenv "$SCOPE" "$TARGET"
    pyenv "$SCOPE" 
  }
fi

function rename_wezterm_title() {
  local PWD="$( pwd )"
  local GIT_DIR="$( git rev-parse --git-common-dir )"
  if [[ -z "$GIT_DIR" ]]; then
    local TITLE="$( basename "$PWD" )"
  else
    local BASE="$( cd "${GIT_DIR}/../.." && pwd )"
    local TITLE="$( realpath --relative-to="$BASE" "$PWD" )"
  fi
  echo "\x1b]1337;SetUserVar=panetitle=$(echo "$TITLE" | base64)\x07"
}

# Plugin: zsh-autosuggestions
ZSH_AUTOSUGGEST_USE_ASYNC=1
ZSH_AUTOSUGGEST_HIGHLIGHT_STYLE='fg=244'

# Plugin: zeno
ATUSY_ACCEPT_LINE="accept-line"
if [[ -n $ZENO_LOADED ]]; then
  bindkey ' '  zeno-auto-snippet
  bindkey '^m' zeno-auto-snippet-and-accept-line
  bindkey '^i' zeno-completion
  bindkey '^r' zeno-history-selection
  bindkey '^x^s' zeno-insert-snippet
  bindkey '^x^f' zeno-ghq-cd
  ZSH_AUTOSUGGEST_CLEAR_WIDGETS+=(zeno-auto-snippet-and-accept-line)
  ATUSY_ACCEPT_LINE="zeno-auto-snippet-and-accept-line"
fi

if [[ -n $NVIM ]] && [[ -n $NVREPL_LOADED ]]; then
  function my-accept-line() {
    nvrepl-line || "$ATUSY_ACCEPT_LINE"
  }
  zle -N my-accept-line
  bindkey '^m' my-accept-line
  ZSH_AUTOSUGGEST_CLEAR_WIDGETS+=(my-accept-line)
fi

# direnv
if command -v direnv >/dev/null; then
  eval "$(direnv hook zsh)"
fi

# local configurations
[[ -f "$HOME/.config/zsh/local.zshrc" ]] && . "$HOME/.config/zsh/local.zshrc"

# zcompile {{{

# .zshrc
# if [[ ! -f ~/.zshrc.zwc ]] || [[ "$(readlink ~/.zshrc)" -nt ~/.zshrc.zwc ]]; then
if [[ ! -f ~/.zshrc.zwc ]] || [[ ~/.zshrc -nt ~/.zshrc.zwc ]]; then
  zcompile ~/.zshrc
fi

# zinit
if [[ ! -f ~/.zinit/bin/zinit.zsh.zwc ]] || [[ ~/.zinit/bin/zinit.zsh -nt ~/.zinit/bin/zinit.zsh.zwc ]]; then
  zcompile ~/.zinit/bin/zinit.zsh
fi

# }}}
#TODO: https://github.com/lambdalisue/dotfiles/blob/eb825140615da791aa8563009c012092c65bcc13/zsh/init.zsh#L107-L116
